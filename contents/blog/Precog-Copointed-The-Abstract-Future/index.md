title: Precog-Copointed The Abstract Future
author: Kris Nuttycombe
date: 2012-11-27 00:00
template: post.jade

<p class="c2">As you might know, we have a talented team of engineers here at Precog who are active on Twitter but sometimes 140 characters just isn&#8217;t enough to express their opinions. So, we&#8217;ve added a monthly blog post dedicated to our Engineers called <strong>Precog.Copointed</strong>. Every month you can read a post authored from one of our engineers that covers topics from software architecture to low-level optimization on the JVM, algorithms, open source software, and maybe even systems administration. Enjoy!</p>
<hr />
<p class="c2">In our <a href="blog-precog-2/entry/existential-types-ftw">last blog post</a> on Precog development, Daniel wrote about how we use the Cake Pattern to structure our codebase and to leave the implementation types abstract as long as possible. As he showed in that post, this is an extremely powerful concept; by keeping a type existential, values of that type remain opaque to any modules that aren't "aware" of the eventual type chosen, and so are prevented by the compiler from breaking encapsulation boundaries.</p>
<p class="c2"><span>In today's post, we're going to extend this notion beyond types to handle type </span><span class="c6">constructors</span><span>, and in so doing will show a mechanism that allows us to switch out entire models of comput</span><span>ation.</span></p>
<p class="c2"><span>If you've been working with Scala for any length of time, you've undoubtedly heard the word "monad" floating around in one context or another, perhaps in a discussion about the syntactic sugar provided by Scala's Ôfor' keyword or a blog post discussing how the Option type can be used to </span><span class="c4"><a class="c3" href="http://www.codecommit.com/blog/scala/the-option-pattern">avoid the pitfalls</a></span><span> of null references. While a significant amount of discussion of monads in Scala focuses on the "container" types, a few types common in the Scala ecosystem display a more interesting facet of monadic composition Ð </span><span class="c6">delimited computation</span><span>. While all monadic types exhibit this in composition, perhaps </span><span>the most commonly used </span><span>monadic type in Scala that exemplifies this sort of use directly is </span><span>akka.dispatch.Future</span><span>, (which is scheduled to replace Scala's current Future interface in the standard library in Scala 2.10) which encodes asynchronous computation.  It embodies the aspect of monadic composition that we're most concerned with here by providing a flexible way to order the steps of a computation.</span></p>
<p class="c2"><span>I'd like to step back a moment here and state that this post isn't intended to function as a monad tutorial; there are numerous (perhaps </span><span class="c4"><a class="c3" href="http://www.codecommit.com/blog/ruby/monads-are-not-metaphors">too many</a></span><span>!) </span><span class="c4"><a class="c3" href="http://james-iry.blogspot.com/2007/09/monads-are-elephants-part-1.html">articles</a></span><span> </span><span class="c4"><a class="c3" href="http://apocalisp.wordpress.com/2011/07/01/monads-are-dominoes/">about</a></span><span> </span><span class="c4"><a class="c3" href="http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">monads</a></span><span>, and their relevance to programming in Scala exist elsewhere. If you're new to the concept it will be useful for you to take advantage of one or more of these resources before continuing here. It is, however, important to point out at first that the use of monads in Scala, while pervasive (as evidenced by the presence of </span><span class="c4"><a class="c3" href="http://debasishg.blogspot.com/2008/03/monads-another-way-to-abstract.html">Ôfor' as syntactic sugar for monadic composition</a></span><span>) is somewhat idiosyncratic in that the Scala standard libraries actually provide no Monad type. For this, we have to look outside of the standard library to the excellent scalaz project. Scalaz's encoding of the monadic abstraction relies upon the </span><span class="c6">implicit typeclass</span><span> pattern. The base Monad type is shown here, simplified, for reference:</span></p>
<p class="c2"><strong id="internal-source-marker_0.2908493096474558" style="font-family: Courier; font-size: medium; font-weight: normal;"><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">trait Monad[M[_]] {</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  def point[A](a: =&gt; A): M[A]</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  def bind[A, B](m: M[A])(f: A =&gt; M[B]): M[B]</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  def map[A, B](m: M[A])(f: A =&gt; B): M[B] = bind(m)(a =&gt; point(f(a))) </span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">}</span></strong></p>
<p class="c0">You'll note that the Monad trait is not parameterized by a specific type, but instead a <span class="c4"><a class="c3" href="http://debasishg.blogspot.com/2009/01/higher-order-abstractions-in-scala-with.html">type constructor</a></span> of one argument. The methods defined inside of Monad are then parametrically polymorphic, which means that they must provide a specific type to be inserted into the "hole" at the invocation point. This will be important later, when we talk about how to actually take advantage of this abstraction.</p>
<p class="c0">Scalaz provides implementations of this type for most of the monadic types in the Scala standard library, as well as several more sophisticated monadic types, which we'll return to in a moment. For now, however let's talk a bit about Akka's Futures.</p>
<p class="c0">An Akka Future represents a computation whose value is produced asynchronously, and which may fail. Also, as I noted before, akka.dispatch.Future is monadic; that is, it is a type for which the Monad trait above can be trivially implemented and which satisfies the <span class="c6">monad laws</span>, and so it provides an extremely useful primitive for composing asynchronous computations without all sorts of tedious mucking about with manual management of threads and shared mutable state. At Precog, we use Futures extensively, both in a direct fashion and to allow us a composable way to interact with subsystems that are implemented atop Akka's actor framework. Futures are arguably one of the best tools we have for reining in the complexity of asynchronous programming, and so <span class="c5">our</span> many of our early versions of APIs in our codebase exposed Futures directly. For example, here's a snippet of one of our internal APIs, which follows the Cake pattern as described previously.</p>
<p><strong id="internal-source-marker_0.2908493096474558" style="font-family: Courier; font-size: medium; font-weight: normal;"><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">trait DatasetModule {</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  type Dataset </span></strong></p>
<p><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  trait DatasetLike {</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    /** The members of this dataset will be used to determine what sets to</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">        load, and the resulting sets will be unioned together */</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    def load: Future[Dataset]</span></p>
<p><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    /** Sorts the dataset by the specified value function. */</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    def sort(sortBy: /*&#8230;*/): Future[Dataset]</span></p>
<p><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    /** Retains a prefix of this dataset. */</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    def take(size: Int): Dataset</span></p>
<p><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    /** Map members of the dataset into the A type using the specified value </span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">        function, then combine using the resulting monoid */</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    def reduce[A: Monoid](mapTo: /*&#8230;*/): Future[A]</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  }</span></p>
<p class="c2"><strong id="internal-source-marker_0.2908493096474558" style="font-family: Courier; font-size: medium; font-weight: normal;"><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">}</span></strong></p>
<p class="c0">The Dataset type here is something of a strawman, but is loosely representative of the type that we use internally to represent an intermediate result of a computation &#8211; a lazy data structure with a number of operations that can be used to manipulate it, some of which may involve actually evaluating a function over the entire dataset and which may involve I/O, distributed evaluation, and asynchronous computation. Based on this interface, it's easy to see that evaluation of some query with respect to a dataset might involve a load, a sort, taking a prefix, and a reduction of that prefix. Moreover, such an evaluation will not rely upon anything except the monadic nature of Future to compose its steps. What this means is that from the perspective of the consumer of the DatasetModule interface, the only aspect of Future that we're relying upon is the ability to order operations in a statically checked fashion; the sequencing, rather than any particular semantics related to Future's asynchrony, is the relevant piece of information provided by the type. So, the following generalization becomes natural:</p>
<p class="c2"><strong id="internal-source-marker_0.2908493096474558" style="font-family: Courier; font-size: medium; font-weight: normal;"><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">trait DatasetModule[M[+_]] {</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  type Dataset<br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  implicit def M: Monad[M]</span></span></strong></p>
<p><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  trait DatasetLike {</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    /** The members of this dataset will be used to determine what sets to</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">        load, and the resulting sets will be unioned together */</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    def load: M[Dataset]</span></p>
<p><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    /** Sorts the dataset by the specified value function. */</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    def sort(sortBy: /*&#8230;*/): M[Dataset]</span></p>
<p><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    /** Retains a prefix of this dataset. */</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    def take(size: Int): Dataset</span></p>
<p><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    /** Map members of the dataset into the A type using the specified value </span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">        function, then combine using the resulting monoid */</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    def reduce[A: Monoid](mapTo: /*&#8230;*/): M[A]</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  }</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">}</span></p>
<p class="c0">and, of course, down the road some concrete implementation of DatasetModule will refine the type constructor M to be Future:</p>
<p class="c2"><strong id="internal-source-marker_0.2908493096474558" style="font-family: Courier; font-size: medium; font-weight: normal;"><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">/** The implicit ExecutionContext is necessary for the implementation of </span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    M.point */</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">class FutureMonad(implicit executor: ExecutionContext) extends Monad[Future] {</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  override def point[A](a: =&gt; A): Future[A] = Future { a }</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  override def bind[A, B](m: Future[A])(f: A =&gt; Future[B]): Future[B] = </span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    m flatMap f</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">}</span></strong></p>
<p><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">abstract class ConcreteDatasetModule(implicit executor: ExecutionContext) </span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">extends DatasetModule[Future] {</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  val M: Monad[Future] = new FutureMonad </span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">}</span></p>
<p class="c0">In practice, we may actually leave M abstract until "the end of the universe." In the Precog codebase, the M type will frequently represent the bottom of a stack of <span class="c4"><a class="c3" href="http://www.google.com/url?q=http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.42.2605&amp;rep=rep1&amp;type=pdf&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGRSdU_Hqlt5jrUfkaG1Ga41BUB3Q">monad transformers </a></span>including StateT, StreamT, EitherT and others that the actual implementation of the Dataset type depends upon.</p>
<p class="c2"><span>This generalization has numerous benefits. First, as with the previous examples of our use of the Cake pattern, consumers of the DatasetModule trait are completely and statically insulated from irrelevant details of the implementation type. An important such consumer is a test suite. In a test, we probably don't want to worry about the fact that the computation is being performed asynchronously; all that we care about is that we obtain a correct result. If our M is in fact at the bottom of a transformer stack, </span><span>we can trivially replace it with the </span><span class="c4"><a class="c3" href="https://github.com/scalaz/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/Id.scala">identity monad</a> </span><span>and use the "copointed" nature of this monad (the ability to "extract" a value from the monadic context). This allows us to build a similarly generic test harness:</span></p>
<p><strong id="internal-source-marker_0.2908493096474558" style="font-family: Courier; font-size: medium; font-weight: normal;"><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">/** Copointed is available from scalaz as well; reproduced here for clarity */</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">trait Copointed[M[_]] {</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  /** Extract and return the value from the enclosing context. */</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  def copoint[A](m: M[A]): A</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">}</span></strong></p>
<p><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">trait TestDatasetModule[M[+_]] extends DatasetModule {</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  implicit def M: Monad[M] with Copointed[M]</span></p>
<p><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  //&#8230; utilities for test dataset generation, stubbing load/sort, etc.</span></p>
<p class="c2"><strong id="internal-source-marker_0.2908493096474558" style="font-family: Courier; font-size: medium; font-weight: normal;"><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">}</span></strong></p>
<p class="c2"><strong id="internal-source-marker_0.2908493096474558" style="font-family: Courier; font-size: medium; font-weight: normal;"></strong>For most cases, we'll use the identity monad for testing. Suppose that we're testing the piece of functionality described earlier, which has computed a result from the combination of a load, a sort, take and reduce. The test framework need never consider the monad that it's operating in.</p>
<p class="c2"><strong id="internal-source-marker_0.2908493096474558" style="font-family: Courier; font-size: medium; font-weight: normal;"><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">import scalaz._</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">import scalaz.syntax.monad._</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">import scalaz.syntax.copointed._</span></strong></p>
<p><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">class MyEvaluationSpec extends Specification {</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  val module = new TestDatasetModule[Id] with ConcreteDatasetModule[Id] { </span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    val M = Monad[Id] // the monad for Id is copointed in Scalaz.</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  }</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  </span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  "evaluation" should {</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    "determine the correct result for the load/sort/take/reduce case" in {</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">      val loadFrom: module.Dataset = //&#8230;</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">      val expected: Int = //&#8230;</span></p>
<p><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">      val result = for {</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">        ds<br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">        sorted &#8211; ds.sortBy(mySortFun)</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">        prefix = sorted.take(10)</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">        value &#8211; prefix.reduce[Int]myCountFunc)</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">      } yield value</span></span></p>
<p><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">      result.copoint must_== expected</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    }</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  }</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">}</span></p>
<p class="c2"><span>In the case that we have a portion of the implementation that actually depends upon the specific monadic type (say, for example, that our sort implementation relies on Akka actors and the </span><span class="c4"><a class="c3" href="http://doc.akka.io/docs/akka/2.0.4/scala/actors.html#Ask__Send-And-Receive-Future">"ask" pattern</a></span><span> under the hood, so that we're using Futures) we can simply encode this in our test in a straightforward fashio</span><span>n:</span></p>
<p class="c2"><strong id="internal-source-marker_0.2908493096474558" style="font-family: Courier; font-size: medium; font-weight: normal;"><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">abstract class TestFutureDatasetModule(implicit executor: ExecutionContext)</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">extends TestDatasetModule[Future] {</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  def testTimeout: akka.util.Duration</span></strong></p>
<p><span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  object M extends FutureMonad(executor) with Copointed[Future] {</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">    def copoint[A](m: Future[A]): A = Await.result(m, testTimeout)</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">  }</span><br />
<span style="font-size: 15px; font-family: Consolas; background-color: transparent; vertical-align: baseline; white-space: pre-wrap;">}</span></p>
<p class="c2"><span>Future is, of course, not properly copointed (since Await can throw an exception) but for the purposes of testing (and testing exclusively) this construction is ideal. As before, we get exactly the type that we need, statically determined, at exactly the place that we need it.</span></p>
<p class="c2"><span>In practice, we've found that abstracting away the particular monad that our code is concerned with has aided tremendously with keeping the concerns of different parts of our codebase well isolated, and ensuring that we're simply not able to sidestep the sequencing requirements that are necessary to make a large, functional codebase work together as a coherent whole. As an added benefit, many parts of our application that were not initially designed thinking in terms of parallel execution are able to execute concurrently. For example, in many cases we'll be computing a List[M[...]] and then using the "sequence" function provided by </span><span class="c4"><a class="c3" href="https://github.com/scalaz/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/Traverse.scala">scalaz.Traverse</a></span><span> to turn this into an M[List[...]] &#8211; and when M is future, each element may be computed in parallel, with the final sequenced result becoming available only when all the computations to produce the members of the list are complete. And, ultimately, even this merely touches the surface of a deep pool of composing our computation that is made possible by making this abstraction.</span></p>